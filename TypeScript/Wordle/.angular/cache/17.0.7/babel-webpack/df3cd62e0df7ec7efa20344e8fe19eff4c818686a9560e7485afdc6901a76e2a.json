{"ast":null,"code":"import { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n// This could've been more streamlined with internal state instead of abusing\n// refs to such extent, but then composing hooks and components could not opt out of unnecessary renders.\nfunction useResolvedElement(subscriber, refOrElement) {\n  var lastReportRef = useRef(null);\n  var refOrElementRef = useRef(null);\n  refOrElementRef.current = refOrElement;\n  var cbElementRef = useRef(null); // Calling re-evaluation after each render without using a dep array,\n  // as the ref object's current value could've changed since the last render.\n\n  useEffect(function () {\n    evaluateSubscription();\n  });\n  var evaluateSubscription = useCallback(function () {\n    var cbElement = cbElementRef.current;\n    var refOrElement = refOrElementRef.current; // Ugly ternary. But smaller than an if-else block.\n\n    var element = cbElement ? cbElement : refOrElement ? refOrElement instanceof Element ? refOrElement : refOrElement.current : null;\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber) {\n      return;\n    }\n    if (lastReportRef.current && lastReportRef.current.cleanup) {\n      lastReportRef.current.cleanup();\n    }\n    lastReportRef.current = {\n      element: element,\n      subscriber: subscriber,\n      // Only calling the subscriber, if there's an actual element to report.\n      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.\n      cleanup: element ? subscriber(element) : undefined\n    };\n  }, [subscriber]); // making sure we call the cleanup function on unmount\n\n  useEffect(function () {\n    return function () {\n      if (lastReportRef.current && lastReportRef.current.cleanup) {\n        lastReportRef.current.cleanup();\n        lastReportRef.current = null;\n      }\n    };\n  }, []);\n  return useCallback(function (element) {\n    cbElementRef.current = element;\n    evaluateSubscription();\n  }, [evaluateSubscription]);\n}\n\n// We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\nfunction extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] :\n  // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n}\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n  var _useState = useState({\n      width: undefined,\n      height: undefined\n    }),\n    size = _useState[0],\n    setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    didUnmount.current = false;\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(useCallback(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size.width, size.height]);\n}\nexport { useResizeObserver as default };","map":{"version":3,"names":["useRef","useEffect","useCallback","useState","useMemo","useResolvedElement","subscriber","refOrElement","lastReportRef","refOrElementRef","current","cbElementRef","evaluateSubscription","cbElement","element","Element","cleanup","undefined","extractSize","entry","boxProp","sizeType","contentRect","useResizeObserver","opts","onResize","onResizeRef","round","Math","resizeObserverRef","_useState","width","height","size","setSize","didUnmount","previous","refCallback","box","instance","ResizeObserver","entries","reportedWidth","reportedHeight","newWidth","newHeight","newSize","observe","unobserve","ref","default"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/use-resize-observer/dist/bundle.esm.js"],"sourcesContent":["import { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n// This could've been more streamlined with internal state instead of abusing\n// refs to such extent, but then composing hooks and components could not opt out of unnecessary renders.\nfunction useResolvedElement(subscriber, refOrElement) {\n  var lastReportRef = useRef(null);\n  var refOrElementRef = useRef(null);\n  refOrElementRef.current = refOrElement;\n  var cbElementRef = useRef(null); // Calling re-evaluation after each render without using a dep array,\n  // as the ref object's current value could've changed since the last render.\n\n  useEffect(function () {\n    evaluateSubscription();\n  });\n  var evaluateSubscription = useCallback(function () {\n    var cbElement = cbElementRef.current;\n    var refOrElement = refOrElementRef.current; // Ugly ternary. But smaller than an if-else block.\n\n    var element = cbElement ? cbElement : refOrElement ? refOrElement instanceof Element ? refOrElement : refOrElement.current : null;\n\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber) {\n      return;\n    }\n\n    if (lastReportRef.current && lastReportRef.current.cleanup) {\n      lastReportRef.current.cleanup();\n    }\n\n    lastReportRef.current = {\n      element: element,\n      subscriber: subscriber,\n      // Only calling the subscriber, if there's an actual element to report.\n      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.\n      cleanup: element ? subscriber(element) : undefined\n    };\n  }, [subscriber]); // making sure we call the cleanup function on unmount\n\n  useEffect(function () {\n    return function () {\n      if (lastReportRef.current && lastReportRef.current.cleanup) {\n        lastReportRef.current.cleanup();\n        lastReportRef.current = null;\n      }\n    };\n  }, []);\n  return useCallback(function (element) {\n    cbElementRef.current = element;\n    evaluateSubscription();\n  }, [evaluateSubscription]);\n}\n\n// We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\nfunction extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    didUnmount.current = false;\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(useCallback(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size.width, size.height]);\n}\n\nexport { useResizeObserver as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}