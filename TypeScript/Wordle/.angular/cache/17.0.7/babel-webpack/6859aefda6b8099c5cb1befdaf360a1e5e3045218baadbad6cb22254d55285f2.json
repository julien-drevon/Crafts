{"ast":null,"code":"import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport { getWindow } from '../utils/misc/getWindow.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { setUIValueClean, setUISelection, hasUISelection } from './UI.js';\nconst TrackChanges = Symbol('Track programmatic changes for React workaround');\n// When the input event happens in the browser, React executes all event handlers\n// and if they change state of a controlled value, nothing happens.\n// But when we trigger the event handlers in test environment with React@17,\n// the changes are rolled back before the state update is applied.\n// This results in a reset cursor.\n// There might be a better way to work around if we figure out\n// why the batched update is executed differently in our test environment.\nfunction isReact17Element(element) {\n  return Object.getOwnPropertyNames(element).some(k => k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;\n}\nfunction startTrackValue(element) {\n  if (!isReact17Element(element)) {\n    return;\n  }\n  element[TrackChanges] = {\n    previousValue: String(element.value),\n    tracked: []\n  };\n}\nfunction trackOrSetValue(element, v) {\n  var _element_TrackChanges_tracked, _element_TrackChanges;\n  (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 ? void 0 : (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 ? void 0 : _element_TrackChanges_tracked.push(v);\n  if (!element[TrackChanges]) {\n    setUIValueClean(element);\n    setUISelection(element, {\n      focusOffset: v.length\n    });\n  }\n}\nfunction commitValueAfterInput(element, cursorOffset) {\n  var _changes_tracked;\n  const changes = element[TrackChanges];\n  element[TrackChanges] = undefined;\n  if (!(changes === null || changes === void 0 ? void 0 : (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0 ? void 0 : _changes_tracked.length)) {\n    return;\n  }\n  const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;\n  if (!isJustReactStateUpdate) {\n    setUIValueClean(element);\n  }\n  if (hasUISelection(element)) {\n    setUISelection(element, {\n      focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length\n    });\n  }\n}\nexport { commitValueAfterInput, startTrackValue, trackOrSetValue };","map":{"version":3,"names":["getWindow","setUIValueClean","setUISelection","hasUISelection","TrackChanges","Symbol","isReact17Element","element","Object","getOwnPropertyNames","some","k","startsWith","REACT_VERSION","startTrackValue","previousValue","String","value","tracked","trackOrSetValue","v","_element_TrackChanges_tracked","_element_TrackChanges","push","focusOffset","length","commitValueAfterInput","cursorOffset","_changes_tracked","changes","undefined","isJustReactStateUpdate"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/document/trackValue.js"],"sourcesContent":["import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport { getWindow } from '../utils/misc/getWindow.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { setUIValueClean, setUISelection, hasUISelection } from './UI.js';\n\nconst TrackChanges = Symbol('Track programmatic changes for React workaround');\n// When the input event happens in the browser, React executes all event handlers\n// and if they change state of a controlled value, nothing happens.\n// But when we trigger the event handlers in test environment with React@17,\n// the changes are rolled back before the state update is applied.\n// This results in a reset cursor.\n// There might be a better way to work around if we figure out\n// why the batched update is executed differently in our test environment.\nfunction isReact17Element(element) {\n    return Object.getOwnPropertyNames(element).some((k)=>k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;\n}\nfunction startTrackValue(element) {\n    if (!isReact17Element(element)) {\n        return;\n    }\n    element[TrackChanges] = {\n        previousValue: String(element.value),\n        tracked: []\n    };\n}\nfunction trackOrSetValue(element, v) {\n    var _element_TrackChanges_tracked, _element_TrackChanges;\n    (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 ? void 0 : (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 ? void 0 : _element_TrackChanges_tracked.push(v);\n    if (!element[TrackChanges]) {\n        setUIValueClean(element);\n        setUISelection(element, {\n            focusOffset: v.length\n        });\n    }\n}\nfunction commitValueAfterInput(element, cursorOffset) {\n    var _changes_tracked;\n    const changes = element[TrackChanges];\n    element[TrackChanges] = undefined;\n    if (!(changes === null || changes === void 0 ? void 0 : (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0 ? void 0 : _changes_tracked.length)) {\n        return;\n    }\n    const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;\n    if (!isJustReactStateUpdate) {\n        setUIValueClean(element);\n    }\n    if (hasUISelection(element)) {\n        setUISelection(element, {\n            focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length\n        });\n    }\n}\n\nexport { commitValueAfterInput, startTrackValue, trackOrSetValue };\n"],"mappings":"AAAA,OAAO,oCAAoC;AAC3C,OAAO,oCAAoC;AAC3C,OAAO,6BAA6B;AACpC,OAAO,4BAA4B;AACnC,SAASA,SAAS,QAAQ,4BAA4B;AACtD,OAAO,uCAAuC;AAC9C,OAAO,wBAAwB;AAC/B,OAAO,eAAe;AACtB,SAASC,eAAe,EAAEC,cAAc,EAAEC,cAAc,QAAQ,SAAS;AAEzE,MAAMC,YAAY,GAAGC,MAAM,CAAC,iDAAiD,CAAC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,OAAO,EAAE;EAC/B,OAAOC,MAAM,CAACC,mBAAmB,CAACF,OAAO,CAAC,CAACG,IAAI,CAAEC,CAAC,IAAGA,CAAC,CAACC,UAAU,CAAC,SAAS,CAAC,CAAC,IAAIZ,SAAS,CAACO,OAAO,CAAC,CAACM,aAAa,KAAK,EAAE;AAC5H;AACA,SAASC,eAAeA,CAACP,OAAO,EAAE;EAC9B,IAAI,CAACD,gBAAgB,CAACC,OAAO,CAAC,EAAE;IAC5B;EACJ;EACAA,OAAO,CAACH,YAAY,CAAC,GAAG;IACpBW,aAAa,EAAEC,MAAM,CAACT,OAAO,CAACU,KAAK,CAAC;IACpCC,OAAO,EAAE;EACb,CAAC;AACL;AACA,SAASC,eAAeA,CAACZ,OAAO,EAAEa,CAAC,EAAE;EACjC,IAAIC,6BAA6B,EAAEC,qBAAqB;EACxD,CAACA,qBAAqB,GAAGf,OAAO,CAACH,YAAY,CAAC,MAAM,IAAI,IAAIkB,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACD,6BAA6B,GAAGC,qBAAqB,CAACJ,OAAO,MAAM,IAAI,IAAIG,6BAA6B,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,6BAA6B,CAACE,IAAI,CAACH,CAAC,CAAC;EAC7Q,IAAI,CAACb,OAAO,CAACH,YAAY,CAAC,EAAE;IACxBH,eAAe,CAACM,OAAO,CAAC;IACxBL,cAAc,CAACK,OAAO,EAAE;MACpBiB,WAAW,EAAEJ,CAAC,CAACK;IACnB,CAAC,CAAC;EACN;AACJ;AACA,SAASC,qBAAqBA,CAACnB,OAAO,EAAEoB,YAAY,EAAE;EAClD,IAAIC,gBAAgB;EACpB,MAAMC,OAAO,GAAGtB,OAAO,CAACH,YAAY,CAAC;EACrCG,OAAO,CAACH,YAAY,CAAC,GAAG0B,SAAS;EACjC,IAAI,EAAED,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACD,gBAAgB,GAAGC,OAAO,CAACX,OAAO,MAAM,IAAI,IAAIU,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACH,MAAM,CAAC,EAAE;IACtK;EACJ;EACA,MAAMM,sBAAsB,GAAGF,OAAO,CAACX,OAAO,CAACO,MAAM,KAAK,CAAC,IAAII,OAAO,CAACX,OAAO,CAAC,CAAC,CAAC,KAAKW,OAAO,CAACd,aAAa,IAAIc,OAAO,CAACX,OAAO,CAAC,CAAC,CAAC,KAAKX,OAAO,CAACU,KAAK;EACnJ,IAAI,CAACc,sBAAsB,EAAE;IACzB9B,eAAe,CAACM,OAAO,CAAC;EAC5B;EACA,IAAIJ,cAAc,CAACI,OAAO,CAAC,EAAE;IACzBL,cAAc,CAACK,OAAO,EAAE;MACpBiB,WAAW,EAAEO,sBAAsB,GAAGJ,YAAY,GAAGpB,OAAO,CAACU,KAAK,CAACQ;IACvE,CAAC,CAAC;EACN;AACJ;AAEA,SAASC,qBAAqB,EAAEZ,eAAe,EAAEK,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}