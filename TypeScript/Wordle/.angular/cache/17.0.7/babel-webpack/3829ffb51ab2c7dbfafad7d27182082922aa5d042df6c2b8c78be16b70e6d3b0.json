{"ast":null,"code":"import { getUIValue } from '../../document/UI.js';\nimport '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\nfunction resolveCaretPosition({\n  target,\n  node,\n  offset\n}) {\n  if (hasOwnSelection(target)) {\n    return {\n      node: target,\n      offset: offset !== null && offset !== void 0 ? offset : getUIValue(target).length\n    };\n  } else if (node) {\n    return {\n      node,\n      offset: offset !== null && offset !== void 0 ? offset : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length\n    };\n  }\n  return findNodeAtTextOffset(target, offset);\n}\nfunction findNodeAtTextOffset(node, offset, isRoot = true) {\n  // When clicking after the content the browser behavior can be complicated:\n  // 1. If there is textContent after the last element child,\n  // the cursor is moved there.\n  // 2. If there is textContent in the last element child,\n  // the browser moves the cursor to the last non-empty text node inside this element.\n  // 3. Otherwise the cursor is moved to the end of the target.\n  let i = offset === undefined ? node.childNodes.length - 1 : 0;\n  const step = offset === undefined ? -1 : +1;\n  while (offset === undefined ? i >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i <= node.childNodes.length) {\n    if (offset && i === node.childNodes.length) {\n      throw new Error('The given offset is out of bounds.');\n    }\n    const c = node.childNodes.item(i);\n    const text = String(c.textContent);\n    if (text.length) {\n      if (offset !== undefined && text.length < offset) {\n        offset -= text.length;\n      } else if (c.nodeType === 1) {\n        return findNodeAtTextOffset(c, offset, false);\n      } else {\n        // The pre-commit hooks keeps changing this\n        // See https://github.com/kentcdodds/kcd-scripts/issues/218\n        /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if\n        if (c.nodeType === 3) {\n          return {\n            node: c,\n            offset: offset !== null && offset !== void 0 ? offset : c.nodeValue.length\n          };\n        }\n      }\n    }\n    i += step;\n  }\n  return {\n    node,\n    offset: node.childNodes.length\n  };\n}\nexport { resolveCaretPosition };","map":{"version":3,"names":["getUIValue","hasOwnSelection","resolveCaretPosition","target","node","offset","length","nodeType","nodeValue","childNodes","findNodeAtTextOffset","isRoot","i","undefined","step","Math","max","Error","c","item","text","String","textContent"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/event/selection/resolveCaretPosition.js"],"sourcesContent":["import { getUIValue } from '../../document/UI.js';\nimport '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\n\nfunction resolveCaretPosition({ target, node, offset }) {\n    if (hasOwnSelection(target)) {\n        return {\n            node: target,\n            offset: offset !== null && offset !== void 0 ? offset : getUIValue(target).length\n        };\n    } else if (node) {\n        return {\n            node,\n            offset: offset !== null && offset !== void 0 ? offset : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length\n        };\n    }\n    return findNodeAtTextOffset(target, offset);\n}\nfunction findNodeAtTextOffset(node, offset, isRoot = true) {\n    // When clicking after the content the browser behavior can be complicated:\n    // 1. If there is textContent after the last element child,\n    // the cursor is moved there.\n    // 2. If there is textContent in the last element child,\n    // the browser moves the cursor to the last non-empty text node inside this element.\n    // 3. Otherwise the cursor is moved to the end of the target.\n    let i = offset === undefined ? node.childNodes.length - 1 : 0;\n    const step = offset === undefined ? -1 : +1;\n    while(offset === undefined ? i >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i <= node.childNodes.length){\n        if (offset && i === node.childNodes.length) {\n            throw new Error('The given offset is out of bounds.');\n        }\n        const c = node.childNodes.item(i);\n        const text = String(c.textContent);\n        if (text.length) {\n            if (offset !== undefined && text.length < offset) {\n                offset -= text.length;\n            } else if (c.nodeType === 1) {\n                return findNodeAtTextOffset(c, offset, false);\n            } else {\n                // The pre-commit hooks keeps changing this\n                // See https://github.com/kentcdodds/kcd-scripts/issues/218\n                /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if\n                if (c.nodeType === 3) {\n                    return {\n                        node: c,\n                        offset: offset !== null && offset !== void 0 ? offset : c.nodeValue.length\n                    };\n                }\n            }\n        }\n        i += step;\n    }\n    return {\n        node,\n        offset: node.childNodes.length\n    };\n}\n\nexport { resolveCaretPosition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}