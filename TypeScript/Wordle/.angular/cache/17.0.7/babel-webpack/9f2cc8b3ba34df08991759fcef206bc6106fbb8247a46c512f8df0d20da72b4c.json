{"ast":null,"code":"import { isContentEditable } from '../edit/isContentEditable.js';\nimport { isElementType } from '../misc/isElementType.js';\nfunction getNextCursorPosition(node, offset, direction, inputType) {\n  // The behavior at text node zero offset is inconsistent.\n  // When walking backwards:\n  // Firefox always moves to zero offset and jumps over last offset.\n  // Chrome jumps over zero offset per default but over last offset when Shift is pressed.\n  // The cursor always moves to zero offset if the focus area (contenteditable or body) ends there.\n  // When walking foward both ignore zero offset.\n  // When walking over input elements the cursor moves before or after that element.\n  // When walking over line breaks the cursor moves inside any following text node.\n  if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) {\n    return {\n      node,\n      offset: offset + direction\n    };\n  }\n  const nextNode = getNextCharacterContentNode(node, offset, direction);\n  if (nextNode) {\n    if (isTextNode(nextNode)) {\n      return {\n        node: nextNode,\n        offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)\n      };\n    } else if (isElementType(nextNode, 'br')) {\n      const nextPlusOne = getNextCharacterContentNode(nextNode, undefined, direction);\n      if (!nextPlusOne) {\n        // The behavior when there is no possible cursor position beyond the line break is inconsistent.\n        // In Chrome outside of contenteditable moving before a leading line break is possible.\n        // A leading line break can still be removed per deleteContentBackward.\n        // A trailing line break on the other hand is not removed by deleteContentForward.\n        if (direction < 0 && inputType === 'deleteContentBackward') {\n          return {\n            node: nextNode.parentNode,\n            offset: getOffset(nextNode)\n          };\n        }\n        return undefined;\n      } else if (isTextNode(nextPlusOne)) {\n        return {\n          node: nextPlusOne,\n          offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length\n        };\n      } else if (direction < 0 && isElementType(nextPlusOne, 'br')) {\n        return {\n          node: nextNode.parentNode,\n          offset: getOffset(nextNode)\n        };\n      } else {\n        return {\n          node: nextPlusOne.parentNode,\n          offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)\n        };\n      }\n    } else {\n      return {\n        node: nextNode.parentNode,\n        offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)\n      };\n    }\n  }\n}\nfunction getNextCharacterContentNode(node, offset, direction) {\n  const nextOffset = Number(offset) + (direction < 0 ? -1 : 0);\n  if (offset !== undefined && isElement(node) && nextOffset >= 0 && nextOffset < node.children.length) {\n    node = node.children[nextOffset];\n  }\n  return walkNodes(node, direction === 1 ? 'next' : 'previous', isTreatedAsCharacterContent);\n}\nfunction isTreatedAsCharacterContent(node) {\n  if (isTextNode(node)) {\n    return true;\n  }\n  if (isElement(node)) {\n    if (isElementType(node, ['input', 'textarea'])) {\n      return node.type !== 'hidden';\n    } else if (isElementType(node, 'br')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getOffset(node) {\n  let i = 0;\n  while (node.previousSibling) {\n    i++;\n    node = node.previousSibling;\n  }\n  return i;\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction isTextNode(node) {\n  return node.nodeType === 3;\n}\nfunction walkNodes(node, direction, callback) {\n  for (;;) {\n    var _node_ownerDocument;\n    const sibling = node[`${direction}Sibling`];\n    if (sibling) {\n      node = getDescendant(sibling, direction === 'next' ? 'first' : 'last');\n      if (callback(node)) {\n        return node;\n      }\n    } else if (node.parentNode && (!isElement(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body))) {\n      node = node.parentNode;\n    } else {\n      break;\n    }\n  }\n}\nfunction getDescendant(node, direction) {\n  while (node.hasChildNodes()) {\n    node = node[`${direction}Child`];\n  }\n  return node;\n}\nexport { getNextCursorPosition };","map":{"version":3,"names":["isContentEditable","isElementType","getNextCursorPosition","node","offset","direction","inputType","isTextNode","nodeValue","length","nextNode","getNextCharacterContentNode","Math","min","max","nextPlusOne","undefined","parentNode","getOffset","nextOffset","Number","isElement","children","walkNodes","isTreatedAsCharacterContent","type","i","previousSibling","nodeType","callback","_node_ownerDocument","sibling","getDescendant","ownerDocument","body","hasChildNodes"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Storybook/node_modules/@testing-library/user-event/dist/esm/utils/focus/cursor.js"],"sourcesContent":["import { isContentEditable } from '../edit/isContentEditable.js';\nimport { isElementType } from '../misc/isElementType.js';\n\nfunction getNextCursorPosition(node, offset, direction, inputType) {\n    // The behavior at text node zero offset is inconsistent.\n    // When walking backwards:\n    // Firefox always moves to zero offset and jumps over last offset.\n    // Chrome jumps over zero offset per default but over last offset when Shift is pressed.\n    // The cursor always moves to zero offset if the focus area (contenteditable or body) ends there.\n    // When walking foward both ignore zero offset.\n    // When walking over input elements the cursor moves before or after that element.\n    // When walking over line breaks the cursor moves inside any following text node.\n    if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) {\n        return {\n            node,\n            offset: offset + direction\n        };\n    }\n    const nextNode = getNextCharacterContentNode(node, offset, direction);\n    if (nextNode) {\n        if (isTextNode(nextNode)) {\n            return {\n                node: nextNode,\n                offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)\n            };\n        } else if (isElementType(nextNode, 'br')) {\n            const nextPlusOne = getNextCharacterContentNode(nextNode, undefined, direction);\n            if (!nextPlusOne) {\n                // The behavior when there is no possible cursor position beyond the line break is inconsistent.\n                // In Chrome outside of contenteditable moving before a leading line break is possible.\n                // A leading line break can still be removed per deleteContentBackward.\n                // A trailing line break on the other hand is not removed by deleteContentForward.\n                if (direction < 0 && inputType === 'deleteContentBackward') {\n                    return {\n                        node: nextNode.parentNode,\n                        offset: getOffset(nextNode)\n                    };\n                }\n                return undefined;\n            } else if (isTextNode(nextPlusOne)) {\n                return {\n                    node: nextPlusOne,\n                    offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length\n                };\n            } else if (direction < 0 && isElementType(nextPlusOne, 'br')) {\n                return {\n                    node: nextNode.parentNode,\n                    offset: getOffset(nextNode)\n                };\n            } else {\n                return {\n                    node: nextPlusOne.parentNode,\n                    offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)\n                };\n            }\n        } else {\n            return {\n                node: nextNode.parentNode,\n                offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)\n            };\n        }\n    }\n}\nfunction getNextCharacterContentNode(node, offset, direction) {\n    const nextOffset = Number(offset) + (direction < 0 ? -1 : 0);\n    if (offset !== undefined && isElement(node) && nextOffset >= 0 && nextOffset < node.children.length) {\n        node = node.children[nextOffset];\n    }\n    return walkNodes(node, direction === 1 ? 'next' : 'previous', isTreatedAsCharacterContent);\n}\nfunction isTreatedAsCharacterContent(node) {\n    if (isTextNode(node)) {\n        return true;\n    }\n    if (isElement(node)) {\n        if (isElementType(node, [\n            'input',\n            'textarea'\n        ])) {\n            return node.type !== 'hidden';\n        } else if (isElementType(node, 'br')) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getOffset(node) {\n    let i = 0;\n    while(node.previousSibling){\n        i++;\n        node = node.previousSibling;\n    }\n    return i;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isTextNode(node) {\n    return node.nodeType === 3;\n}\nfunction walkNodes(node, direction, callback) {\n    for(;;){\n        var _node_ownerDocument;\n        const sibling = node[`${direction}Sibling`];\n        if (sibling) {\n            node = getDescendant(sibling, direction === 'next' ? 'first' : 'last');\n            if (callback(node)) {\n                return node;\n            }\n        } else if (node.parentNode && (!isElement(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body))) {\n            node = node.parentNode;\n        } else {\n            break;\n        }\n    }\n}\nfunction getDescendant(node, direction) {\n    while(node.hasChildNodes()){\n        node = node[`${direction}Child`];\n    }\n    return node;\n}\n\nexport { getNextCursorPosition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}