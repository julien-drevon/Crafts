{"ast":null,"code":"import '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport { getContentEditable } from '../../utils/edit/isContentEditable.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\n\n/**\n * Reset the Document Selection when moving focus into an element\n * with own selection implementation.\n */\nfunction updateSelectionOnFocus(element) {\n  const selection = element.ownerDocument.getSelection();\n  /* istanbul ignore if */\n  if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {\n    return;\n  }\n  // If the focus moves inside an element with own selection implementation,\n  // the document selection will be this element.\n  // But if the focused element is inside a contenteditable,\n  // 1) a collapsed selection will be retained.\n  // 2) other selections will be replaced by a cursor\n  //  2.a) at the start of the first child if it is a text node\n  //  2.b) at the start of the contenteditable.\n  if (hasOwnSelection(element)) {\n    const contenteditable = getContentEditable(selection.focusNode);\n    if (contenteditable) {\n      if (!selection.isCollapsed) {\n        var _contenteditable_firstChild;\n        const focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;\n        selection.setBaseAndExtent(focusNode, 0, focusNode, 0);\n      }\n    } else {\n      selection.setBaseAndExtent(element, 0, element, 0);\n    }\n  }\n}\nexport { updateSelectionOnFocus };","map":{"version":3,"names":["getContentEditable","hasOwnSelection","updateSelectionOnFocus","element","selection","ownerDocument","getSelection","focusNode","contenteditable","isCollapsed","_contenteditable_firstChild","firstChild","nodeType","setBaseAndExtent"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/event/selection/updateSelectionOnFocus.js"],"sourcesContent":["import '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport { getContentEditable } from '../../utils/edit/isContentEditable.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\n\n/**\n * Reset the Document Selection when moving focus into an element\n * with own selection implementation.\n */ function updateSelectionOnFocus(element) {\n    const selection = element.ownerDocument.getSelection();\n    /* istanbul ignore if */ if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {\n        return;\n    }\n    // If the focus moves inside an element with own selection implementation,\n    // the document selection will be this element.\n    // But if the focused element is inside a contenteditable,\n    // 1) a collapsed selection will be retained.\n    // 2) other selections will be replaced by a cursor\n    //  2.a) at the start of the first child if it is a text node\n    //  2.b) at the start of the contenteditable.\n    if (hasOwnSelection(element)) {\n        const contenteditable = getContentEditable(selection.focusNode);\n        if (contenteditable) {\n            if (!selection.isCollapsed) {\n                var _contenteditable_firstChild;\n                const focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;\n                selection.setBaseAndExtent(focusNode, 0, focusNode, 0);\n            }\n        } else {\n            selection.setBaseAndExtent(element, 0, element, 0);\n        }\n    }\n}\n\nexport { updateSelectionOnFocus };\n"],"mappings":"AAAA,OAAO,uCAAuC;AAC9C,OAAO,uCAAuC;AAC9C,SAASA,kBAAkB,QAAQ,uCAAuC;AAC1E,OAAO,gCAAgC;AACvC,OAAO,+BAA+B;AACtC,OAAO,sCAAsC;AAC7C,SAASC,eAAe,QAAQ,gCAAgC;AAChE,OAAO,0CAA0C;AACjD,OAAO,2BAA2B;AAClC,OAAO,kBAAkB;;AAEzB;AACA;AACA;AACA;AAAI,SAASC,sBAAsBA,CAACC,OAAO,EAAE;EACzC,MAAMC,SAAS,GAAGD,OAAO,CAACE,aAAa,CAACC,YAAY,CAAC,CAAC;EACtD;EAAyB,IAAI,EAAEF,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACG,SAAS,CAAC,EAAE;IACvG;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIN,eAAe,CAACE,OAAO,CAAC,EAAE;IAC1B,MAAMK,eAAe,GAAGR,kBAAkB,CAACI,SAAS,CAACG,SAAS,CAAC;IAC/D,IAAIC,eAAe,EAAE;MACjB,IAAI,CAACJ,SAAS,CAACK,WAAW,EAAE;QACxB,IAAIC,2BAA2B;QAC/B,MAAMH,SAAS,GAAG,CAAC,CAACG,2BAA2B,GAAGF,eAAe,CAACG,UAAU,MAAM,IAAI,IAAID,2BAA2B,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,2BAA2B,CAACE,QAAQ,MAAM,CAAC,GAAGJ,eAAe,CAACG,UAAU,GAAGH,eAAe;QACtOJ,SAAS,CAACS,gBAAgB,CAACN,SAAS,EAAE,CAAC,EAAEA,SAAS,EAAE,CAAC,CAAC;MAC1D;IACJ,CAAC,MAAM;MACHH,SAAS,CAACS,gBAAgB,CAACV,OAAO,EAAE,CAAC,EAAEA,OAAO,EAAE,CAAC,CAAC;IACtD;EACJ;AACJ;AAEA,SAASD,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}