{"ast":null,"code":"import { setUIValue, clearInitialValue, getUIValue } from '../document/UI.js';\nimport '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport { isValidDateOrTimeValue, buildTimeValue } from '../utils/edit/timeValue.js';\nimport '../utils/edit/isEditable.js';\nimport { supportsMaxLength, getMaxLength } from '../utils/edit/maxLength.js';\nimport { getNextCursorPosition } from '../utils/focus/cursor.js';\nimport { isElementType } from '../utils/misc/isElementType.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { commitValueAfterInput } from '../document/trackValue.js';\nimport { getInputRange } from './selection/getInputRange.js';\nimport { setSelection } from './selection/setSelection.js';\nfunction isDateOrTime(element) {\n  return isElementType(element, 'input') && ['date', 'time'].includes(element.type);\n}\nfunction input(instance, element, data, inputType = 'insertText') {\n  const inputRange = getInputRange(element);\n  /* istanbul ignore if */\n  if (!inputRange) {\n    return;\n  }\n  // There is no `beforeinput` event on `date` and `time` input\n  if (!isDateOrTime(element)) {\n    const unprevented = instance.dispatchUIEvent(element, 'beforeinput', {\n      inputType,\n      data\n    });\n    if (!unprevented) {\n      return;\n    }\n  }\n  if ('startContainer' in inputRange) {\n    editContenteditable(instance, element, inputRange, data, inputType);\n  } else {\n    editInputElement(instance, element, inputRange, data, inputType);\n  }\n}\nfunction editContenteditable(instance, element, inputRange, data, inputType) {\n  let del = false;\n  if (!inputRange.collapsed) {\n    del = true;\n    inputRange.deleteContents();\n  } else if (['deleteContentBackward', 'deleteContentForward'].includes(inputType)) {\n    const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === 'deleteContentBackward' ? -1 : 1, inputType);\n    if (nextPosition) {\n      del = true;\n      const delRange = inputRange.cloneRange();\n      if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {\n        delRange.setStart(nextPosition.node, nextPosition.offset);\n      } else {\n        delRange.setEnd(nextPosition.node, nextPosition.offset);\n      }\n      delRange.deleteContents();\n    }\n  }\n  if (data) {\n    if (inputRange.endContainer.nodeType === 3) {\n      const offset = inputRange.endOffset;\n      inputRange.endContainer.insertData(offset, data);\n      inputRange.setStart(inputRange.endContainer, offset + data.length);\n      inputRange.setEnd(inputRange.endContainer, offset + data.length);\n    } else {\n      const text = element.ownerDocument.createTextNode(data);\n      inputRange.insertNode(text);\n      inputRange.setStart(text, data.length);\n      inputRange.setEnd(text, data.length);\n    }\n  }\n  if (del || data) {\n    instance.dispatchUIEvent(element, 'input', {\n      inputType\n    });\n  }\n}\nfunction editInputElement(instance, element, inputRange, data, inputType) {\n  let dataToInsert = data;\n  if (supportsMaxLength(element)) {\n    const maxLength = getMaxLength(element);\n    if (maxLength !== undefined && data.length > 0) {\n      const spaceUntilMaxLength = maxLength - element.value.length;\n      if (spaceUntilMaxLength > 0) {\n        dataToInsert = data.substring(0, spaceUntilMaxLength);\n      } else {\n        return;\n      }\n    }\n  }\n  const {\n    newValue,\n    newOffset,\n    oldValue\n  } = calculateNewValue(dataToInsert, element, inputRange, inputType);\n  if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {\n    return;\n  }\n  if (isElementType(element, 'input', {\n    type: 'number'\n  }) && !isValidNumberInput(newValue)) {\n    return;\n  }\n  setUIValue(element, newValue);\n  setSelection({\n    focusNode: element,\n    anchorOffset: newOffset,\n    focusOffset: newOffset\n  });\n  if (isDateOrTime(element)) {\n    if (isValidDateOrTimeValue(element, newValue)) {\n      commitInput(instance, element, newOffset, {});\n      instance.dispatchUIEvent(element, 'change');\n      clearInitialValue(element);\n    }\n  } else {\n    commitInput(instance, element, newOffset, {\n      data,\n      inputType\n    });\n  }\n}\nfunction calculateNewValue(inputData, node, {\n  startOffset,\n  endOffset\n}, inputType) {\n  const value = getUIValue(node);\n  const prologEnd = Math.max(0, startOffset === endOffset && inputType === 'deleteContentBackward' ? startOffset - 1 : startOffset);\n  const prolog = value.substring(0, prologEnd);\n  const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === 'deleteContentForward' ? startOffset + 1 : endOffset);\n  const epilog = value.substring(epilogStart, value.length);\n  let newValue = `${prolog}${inputData}${epilog}`;\n  let newOffset = prologEnd + inputData.length;\n  if (isElementType(node, 'input', {\n    type: 'time'\n  })) {\n    const builtValue = buildTimeValue(newValue);\n    if (builtValue !== '' && isValidDateOrTimeValue(node, builtValue)) {\n      newValue = builtValue;\n      newOffset = builtValue.length;\n    }\n  }\n  return {\n    oldValue: value,\n    newValue,\n    newOffset\n  };\n}\nfunction commitInput(instance, element, newOffset, inputInit) {\n  instance.dispatchUIEvent(element, 'input', inputInit);\n  commitValueAfterInput(element, newOffset);\n}\nfunction isValidNumberInput(value) {\n  var _value_match, _value_match1;\n  // the browser allows some invalid input but not others\n  // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n  // it allows one '.' at any place before e\n  const valueParts = value.split('e', 2);\n  return !(/[^\\d.\\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value.match(/\\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1]));\n}\nexport { input };","map":{"version":3,"names":["setUIValue","clearInitialValue","getUIValue","isValidDateOrTimeValue","buildTimeValue","supportsMaxLength","getMaxLength","getNextCursorPosition","isElementType","commitValueAfterInput","getInputRange","setSelection","isDateOrTime","element","includes","type","input","instance","data","inputType","inputRange","unprevented","dispatchUIEvent","editContenteditable","editInputElement","del","collapsed","deleteContents","nextPosition","startContainer","startOffset","delRange","cloneRange","comparePoint","node","offset","setStart","setEnd","endContainer","nodeType","endOffset","insertData","length","text","ownerDocument","createTextNode","insertNode","dataToInsert","maxLength","undefined","spaceUntilMaxLength","value","substring","newValue","newOffset","oldValue","calculateNewValue","isValidNumberInput","focusNode","anchorOffset","focusOffset","commitInput","inputData","prologEnd","Math","max","prolog","epilogStart","min","epilog","builtValue","inputInit","_value_match","_value_match1","valueParts","split","test","Number","match"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Storybook/node_modules/@testing-library/user-event/dist/esm/event/input.js"],"sourcesContent":["import { setUIValue, clearInitialValue, getUIValue } from '../document/UI.js';\nimport '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport { isValidDateOrTimeValue, buildTimeValue } from '../utils/edit/timeValue.js';\nimport '../utils/edit/isEditable.js';\nimport { supportsMaxLength, getMaxLength } from '../utils/edit/maxLength.js';\nimport { getNextCursorPosition } from '../utils/focus/cursor.js';\nimport { isElementType } from '../utils/misc/isElementType.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { commitValueAfterInput } from '../document/trackValue.js';\nimport { getInputRange } from './selection/getInputRange.js';\nimport { setSelection } from './selection/setSelection.js';\n\nfunction isDateOrTime(element) {\n    return isElementType(element, 'input') && [\n        'date',\n        'time'\n    ].includes(element.type);\n}\nfunction input(instance, element, data, inputType = 'insertText') {\n    const inputRange = getInputRange(element);\n    /* istanbul ignore if */ if (!inputRange) {\n        return;\n    }\n    // There is no `beforeinput` event on `date` and `time` input\n    if (!isDateOrTime(element)) {\n        const unprevented = instance.dispatchUIEvent(element, 'beforeinput', {\n            inputType,\n            data\n        });\n        if (!unprevented) {\n            return;\n        }\n    }\n    if ('startContainer' in inputRange) {\n        editContenteditable(instance, element, inputRange, data, inputType);\n    } else {\n        editInputElement(instance, element, inputRange, data, inputType);\n    }\n}\nfunction editContenteditable(instance, element, inputRange, data, inputType) {\n    let del = false;\n    if (!inputRange.collapsed) {\n        del = true;\n        inputRange.deleteContents();\n    } else if ([\n        'deleteContentBackward',\n        'deleteContentForward'\n    ].includes(inputType)) {\n        const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === 'deleteContentBackward' ? -1 : 1, inputType);\n        if (nextPosition) {\n            del = true;\n            const delRange = inputRange.cloneRange();\n            if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {\n                delRange.setStart(nextPosition.node, nextPosition.offset);\n            } else {\n                delRange.setEnd(nextPosition.node, nextPosition.offset);\n            }\n            delRange.deleteContents();\n        }\n    }\n    if (data) {\n        if (inputRange.endContainer.nodeType === 3) {\n            const offset = inputRange.endOffset;\n            inputRange.endContainer.insertData(offset, data);\n            inputRange.setStart(inputRange.endContainer, offset + data.length);\n            inputRange.setEnd(inputRange.endContainer, offset + data.length);\n        } else {\n            const text = element.ownerDocument.createTextNode(data);\n            inputRange.insertNode(text);\n            inputRange.setStart(text, data.length);\n            inputRange.setEnd(text, data.length);\n        }\n    }\n    if (del || data) {\n        instance.dispatchUIEvent(element, 'input', {\n            inputType\n        });\n    }\n}\nfunction editInputElement(instance, element, inputRange, data, inputType) {\n    let dataToInsert = data;\n    if (supportsMaxLength(element)) {\n        const maxLength = getMaxLength(element);\n        if (maxLength !== undefined && data.length > 0) {\n            const spaceUntilMaxLength = maxLength - element.value.length;\n            if (spaceUntilMaxLength > 0) {\n                dataToInsert = data.substring(0, spaceUntilMaxLength);\n            } else {\n                return;\n            }\n        }\n    }\n    const { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);\n    if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {\n        return;\n    }\n    if (isElementType(element, 'input', {\n        type: 'number'\n    }) && !isValidNumberInput(newValue)) {\n        return;\n    }\n    setUIValue(element, newValue);\n    setSelection({\n        focusNode: element,\n        anchorOffset: newOffset,\n        focusOffset: newOffset\n    });\n    if (isDateOrTime(element)) {\n        if (isValidDateOrTimeValue(element, newValue)) {\n            commitInput(instance, element, newOffset, {});\n            instance.dispatchUIEvent(element, 'change');\n            clearInitialValue(element);\n        }\n    } else {\n        commitInput(instance, element, newOffset, {\n            data,\n            inputType\n        });\n    }\n}\nfunction calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {\n    const value = getUIValue(node);\n    const prologEnd = Math.max(0, startOffset === endOffset && inputType === 'deleteContentBackward' ? startOffset - 1 : startOffset);\n    const prolog = value.substring(0, prologEnd);\n    const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === 'deleteContentForward' ? startOffset + 1 : endOffset);\n    const epilog = value.substring(epilogStart, value.length);\n    let newValue = `${prolog}${inputData}${epilog}`;\n    let newOffset = prologEnd + inputData.length;\n    if (isElementType(node, 'input', {\n        type: 'time'\n    })) {\n        const builtValue = buildTimeValue(newValue);\n        if (builtValue !== '' && isValidDateOrTimeValue(node, builtValue)) {\n            newValue = builtValue;\n            newOffset = builtValue.length;\n        }\n    }\n    return {\n        oldValue: value,\n        newValue,\n        newOffset\n    };\n}\nfunction commitInput(instance, element, newOffset, inputInit) {\n    instance.dispatchUIEvent(element, 'input', inputInit);\n    commitValueAfterInput(element, newOffset);\n}\nfunction isValidNumberInput(value) {\n    var _value_match, _value_match1;\n    // the browser allows some invalid input but not others\n    // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n    // it allows one '.' at any place before e\n    const valueParts = value.split('e', 2);\n    return !(/[^\\d.\\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value.match(/\\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1]));\n}\n\nexport { input };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}