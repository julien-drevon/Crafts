{"ast":null,"code":"import { getUIValue, setUISelection } from '../../document/UI.js';\nimport '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasNoSelection, hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\nimport { resolveCaretPosition } from './resolveCaretPosition.js';\nfunction setSelectionPerMouseDown({\n  document,\n  target,\n  clickCount,\n  node,\n  offset\n}) {\n  if (hasNoSelection(target)) {\n    return;\n  }\n  const targetHasOwnSelection = hasOwnSelection(target);\n  // On non-input elements the text selection per multiple click\n  // can extend beyond the target boundaries.\n  // The exact mechanism what is considered in the same line is unclear.\n  // Looks it might be every inline element.\n  // TODO: Check what might be considered part of the same line of text.\n  const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);\n  const [start, end] = node ?\n  // which elements might be considered in the same line of text.\n  // TODO: support expanding initial range on multiple clicks if node is given\n  [offset, offset] : getTextRange(text, offset, clickCount);\n  // TODO: implement modifying selection per shift/ctrl+mouse\n  if (targetHasOwnSelection) {\n    setUISelection(target, {\n      anchorOffset: start !== null && start !== void 0 ? start : text.length,\n      focusOffset: end !== null && end !== void 0 ? end : text.length\n    });\n    return {\n      node: target,\n      start: start !== null && start !== void 0 ? start : 0,\n      end: end !== null && end !== void 0 ? end : text.length\n    };\n  } else {\n    const {\n      node: startNode,\n      offset: startOffset\n    } = resolveCaretPosition({\n      target,\n      node,\n      offset: start\n    });\n    const {\n      node: endNode,\n      offset: endOffset\n    } = resolveCaretPosition({\n      target,\n      node,\n      offset: end\n    });\n    const range = target.ownerDocument.createRange();\n    try {\n      range.setStart(startNode, startOffset);\n      range.setEnd(endNode, endOffset);\n    } catch (e) {\n      throw new Error('The given offset is out of bounds.');\n    }\n    const selection = document.getSelection();\n    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n    selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());\n    return range;\n  }\n}\nfunction getTextRange(text, pos, clickCount) {\n  if (clickCount % 3 === 1 || text.length === 0) {\n    return [pos, pos];\n  }\n  const textPos = pos !== null && pos !== void 0 ? pos : text.length;\n  if (clickCount % 3 === 2) {\n    return [textPos - text.substr(0, pos).match(/(\\w+|\\s+|\\W)?$/)[0].length, pos === undefined ? pos : pos + text.substr(pos).match(/^(\\w+|\\s+|\\W)?/)[0].length];\n  }\n  // triple click\n  return [textPos - text.substr(0, pos).match(/[^\\r\\n]*$/)[0].length, pos === undefined ? pos : pos + text.substr(pos).match(/^[^\\r\\n]*/)[0].length];\n}\nexport { setSelectionPerMouseDown };","map":{"version":3,"names":["getUIValue","setUISelection","hasNoSelection","hasOwnSelection","resolveCaretPosition","setSelectionPerMouseDown","document","target","clickCount","node","offset","targetHasOwnSelection","text","String","textContent","start","end","getTextRange","anchorOffset","length","focusOffset","startNode","startOffset","endNode","endOffset","range","ownerDocument","createRange","setStart","setEnd","e","Error","selection","getSelection","removeAllRanges","addRange","cloneRange","pos","textPos","substr","match","undefined"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/event/selection/setSelectionPerMouse.js"],"sourcesContent":["import { getUIValue, setUISelection } from '../../document/UI.js';\nimport '../../utils/click/isClickableInput.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport '../../utils/edit/isEditable.js';\nimport '../../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { hasNoSelection, hasOwnSelection } from '../../utils/focus/selection.js';\nimport '../../utils/keyDef/readNextDescriptor.js';\nimport '../../utils/misc/level.js';\nimport '../../options.js';\nimport { resolveCaretPosition } from './resolveCaretPosition.js';\n\nfunction setSelectionPerMouseDown({ document, target, clickCount, node, offset }) {\n    if (hasNoSelection(target)) {\n        return;\n    }\n    const targetHasOwnSelection = hasOwnSelection(target);\n    // On non-input elements the text selection per multiple click\n    // can extend beyond the target boundaries.\n    // The exact mechanism what is considered in the same line is unclear.\n    // Looks it might be every inline element.\n    // TODO: Check what might be considered part of the same line of text.\n    const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);\n    const [start, end] = node ? // which elements might be considered in the same line of text.\n    // TODO: support expanding initial range on multiple clicks if node is given\n    [\n        offset,\n        offset\n    ] : getTextRange(text, offset, clickCount);\n    // TODO: implement modifying selection per shift/ctrl+mouse\n    if (targetHasOwnSelection) {\n        setUISelection(target, {\n            anchorOffset: start !== null && start !== void 0 ? start : text.length,\n            focusOffset: end !== null && end !== void 0 ? end : text.length\n        });\n        return {\n            node: target,\n            start: start !== null && start !== void 0 ? start : 0,\n            end: end !== null && end !== void 0 ? end : text.length\n        };\n    } else {\n        const { node: startNode, offset: startOffset } = resolveCaretPosition({\n            target,\n            node,\n            offset: start\n        });\n        const { node: endNode, offset: endOffset } = resolveCaretPosition({\n            target,\n            node,\n            offset: end\n        });\n        const range = target.ownerDocument.createRange();\n        try {\n            range.setStart(startNode, startOffset);\n            range.setEnd(endNode, endOffset);\n        } catch (e) {\n            throw new Error('The given offset is out of bounds.');\n        }\n        const selection = document.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range.cloneRange());\n        return range;\n    }\n}\nfunction getTextRange(text, pos, clickCount) {\n    if (clickCount % 3 === 1 || text.length === 0) {\n        return [\n            pos,\n            pos\n        ];\n    }\n    const textPos = pos !== null && pos !== void 0 ? pos : text.length;\n    if (clickCount % 3 === 2) {\n        return [\n            textPos - text.substr(0, pos).match(/(\\w+|\\s+|\\W)?$/)[0].length,\n            pos === undefined ? pos : pos + text.substr(pos).match(/^(\\w+|\\s+|\\W)?/)[0].length\n        ];\n    }\n    // triple click\n    return [\n        textPos - text.substr(0, pos).match(/[^\\r\\n]*$/)[0].length,\n        pos === undefined ? pos : pos + text.substr(pos).match(/^[^\\r\\n]*/)[0].length\n    ];\n}\n\nexport { setSelectionPerMouseDown };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}