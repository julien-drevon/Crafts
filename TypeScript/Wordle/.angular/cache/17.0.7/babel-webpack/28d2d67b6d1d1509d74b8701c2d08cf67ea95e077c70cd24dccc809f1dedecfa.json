{"ast":null,"code":"var bracketDict;\n(function (bracketDict) {\n  bracketDict['{'] = '}';\n  bracketDict['['] = ']';\n})(bracketDict || (bracketDict = {}));\n/**\n * Read the next key definition from user input\n *\n * Describe key per `{descriptor}` or `[descriptor]`.\n * Everything else will be interpreted as a single character as descriptor - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * A previously pressed key can be released per `{/descriptor}`.\n * Keeping the key pressed can be written as `{descriptor>}`.\n * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.\n * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.\n */\nfunction readNextDescriptor(text, context) {\n  let pos = 0;\n  const startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length;\n  const isEscapedChar = new RegExp(`^\\\\${startBracket}{2}`).test(text);\n  const type = isEscapedChar ? '' : startBracket;\n  return {\n    type,\n    ...(type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context))\n  };\n}\nfunction readPrintableChar(text, pos, context) {\n  const descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos, context);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\nfunction readTag(text, pos, startBracket, context) {\n  var _text_slice_match, _text_slice_match1;\n  const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  const escapedDescriptor = startBracket === '{' && text[pos] === '\\\\';\n  pos += Number(escapedDescriptor);\n  const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\\w+|^[^}>/]/ : /^\\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];\n  assertDescriptor(descriptor, text, pos, context);\n  pos += descriptor.length;\n  var _text_slice_match_;\n  const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';\n  pos += repeatModifier.length;\n  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  const expectedEndBracket = bracketDict[startBracket];\n  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text, context));\n  }\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)\n  };\n}\nfunction assertDescriptor(descriptor, text, pos, context) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text, context));\n  }\n}\nfunction hasReleaseSelf(releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n  if (repeatModifier) {\n    return false;\n  }\n}\nfunction getErrorMessage(expected, found, text, context) {\n  return `Expected ${expected} but found \"${found !== null && found !== void 0 ? found : ''}\" in \"${text}\"\n    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}\n    for more information about how userEvent parses your input.`;\n}\nexport { readNextDescriptor };","map":{"version":3,"names":["bracketDict","readNextDescriptor","text","context","pos","startBracket","length","isEscapedChar","RegExp","test","type","readPrintableChar","readTag","descriptor","assertDescriptor","consumedLength","releasePrevious","releaseSelf","repeat","_text_slice_match","_text_slice_match1","releasePreviousModifier","escapedDescriptor","Number","slice","match","_text_slice_match_","repeatModifier","releaseSelfModifier","expectedEndBracket","endBracket","Error","getErrorMessage","filter","Boolean","join","Math","max","substr","hasReleaseSelf","expected","found"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js"],"sourcesContent":["var bracketDict;\n(function(bracketDict) {\n    bracketDict['{'] = '}';\n    bracketDict['['] = ']';\n})(bracketDict || (bracketDict = {}));\n/**\n * Read the next key definition from user input\n *\n * Describe key per `{descriptor}` or `[descriptor]`.\n * Everything else will be interpreted as a single character as descriptor - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * A previously pressed key can be released per `{/descriptor}`.\n * Keeping the key pressed can be written as `{descriptor>}`.\n * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.\n * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.\n */ function readNextDescriptor(text, context) {\n    let pos = 0;\n    const startBracket = text[pos] in bracketDict ? text[pos] : '';\n    pos += startBracket.length;\n    const isEscapedChar = new RegExp(`^\\\\${startBracket}{2}`).test(text);\n    const type = isEscapedChar ? '' : startBracket;\n    return {\n        type,\n        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)\n    };\n}\nfunction readPrintableChar(text, pos, context) {\n    const descriptor = text[pos];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: false,\n        releaseSelf: true,\n        repeat: 1\n    };\n}\nfunction readTag(text, pos, startBracket, context) {\n    var _text_slice_match, _text_slice_match1;\n    const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n    pos += releasePreviousModifier.length;\n    const escapedDescriptor = startBracket === '{' && text[pos] === '\\\\';\n    pos += Number(escapedDescriptor);\n    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\\w+|^[^}>/]/ : /^\\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    var _text_slice_match_;\n    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';\n    pos += repeatModifier.length;\n    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n    pos += releaseSelfModifier.length;\n    const expectedEndBracket = bracketDict[startBracket];\n    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n    if (!endBracket) {\n        throw new Error(getErrorMessage([\n            !repeatModifier && 'repeat modifier',\n            !releaseSelfModifier && 'release modifier',\n            `\"${expectedEndBracket}\"`\n        ].filter(Boolean).join(' or '), text[pos], text, context));\n    }\n    pos += endBracket.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: !!releasePreviousModifier,\n        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)\n    };\n}\nfunction assertDescriptor(descriptor, text, pos, context) {\n    if (!descriptor) {\n        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));\n    }\n}\nfunction hasReleaseSelf(releaseSelfModifier, repeatModifier) {\n    if (releaseSelfModifier) {\n        return releaseSelfModifier === '/';\n    }\n    if (repeatModifier) {\n        return false;\n    }\n}\nfunction getErrorMessage(expected, found, text, context) {\n    return `Expected ${expected} but found \"${found !== null && found !== void 0 ? found : ''}\" in \"${text}\"\n    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}\n    for more information about how userEvent parses your input.`;\n}\n\nexport { readNextDescriptor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}