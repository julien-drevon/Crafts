{"ast":null,"code":"import { isDisabled } from '../misc/isDisabled.js';\nimport { isElementType } from '../misc/isElementType.js';\nimport { isVisible } from '../misc/isVisible.js';\nimport { FOCUSABLE_SELECTOR } from './selector.js';\nfunction getTabDestination(activeElement, shift) {\n  const document = activeElement.ownerDocument;\n  const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);\n  const enabledElements = Array.from(focusableElements).filter(el => el === activeElement || !(Number(el.getAttribute('tabindex')) < 0 || isDisabled(el)));\n  // tabindex has no effect if the active element has negative tabindex\n  if (Number(activeElement.getAttribute('tabindex')) >= 0) {\n    enabledElements.sort((a, b) => {\n      const i = Number(a.getAttribute('tabindex'));\n      const j = Number(b.getAttribute('tabindex'));\n      if (i === j) {\n        return 0;\n      } else if (i === 0) {\n        return 1;\n      } else if (j === 0) {\n        return -1;\n      }\n      return i - j;\n    });\n  }\n  const checkedRadio = {};\n  let prunedElements = [document.body];\n  const activeRadioGroup = isElementType(activeElement, 'input', {\n    type: 'radio'\n  }) ? activeElement.name : undefined;\n  enabledElements.forEach(currentElement => {\n    const el = currentElement;\n    // For radio groups keep only the active radio\n    // If there is no active radio, keep only the checked radio\n    // If there is no checked radio, treat like everything else\n    if (isElementType(el, 'input', {\n      type: 'radio'\n    }) && el.name) {\n      // If the active element is part of the group, add only that\n      if (el === activeElement) {\n        prunedElements.push(el);\n        return;\n      } else if (el.name === activeRadioGroup) {\n        return;\n      }\n      // If we stumble upon a checked radio, remove the others\n      if (el.checked) {\n        prunedElements = prunedElements.filter(e => !isElementType(e, 'input', {\n          type: 'radio',\n          name: el.name\n        }));\n        prunedElements.push(el);\n        checkedRadio[el.name] = el;\n        return;\n      }\n      // If we already found the checked one, skip\n      if (typeof checkedRadio[el.name] !== 'undefined') {\n        return;\n      }\n    }\n    prunedElements.push(el);\n  });\n  for (let index = prunedElements.findIndex(el => el === activeElement);;) {\n    index += shift ? -1 : 1;\n    // loop at overflow\n    if (index === prunedElements.length) {\n      index = 0;\n    } else if (index === -1) {\n      index = prunedElements.length - 1;\n    }\n    if (prunedElements[index] === activeElement || prunedElements[index] === document.body || isVisible(prunedElements[index])) {\n      return prunedElements[index];\n    }\n  }\n}\nexport { getTabDestination };","map":{"version":3,"names":["isDisabled","isElementType","isVisible","FOCUSABLE_SELECTOR","getTabDestination","activeElement","shift","document","ownerDocument","focusableElements","querySelectorAll","enabledElements","Array","from","filter","el","Number","getAttribute","sort","a","b","i","j","checkedRadio","prunedElements","body","activeRadioGroup","type","name","undefined","forEach","currentElement","push","checked","e","index","findIndex","length"],"sources":["C:/Users/drevo/Documents/GitHub/Crafts/TypeScript/Wordle/node_modules/@testing-library/user-event/dist/esm/utils/focus/getTabDestination.js"],"sourcesContent":["import { isDisabled } from '../misc/isDisabled.js';\nimport { isElementType } from '../misc/isElementType.js';\nimport { isVisible } from '../misc/isVisible.js';\nimport { FOCUSABLE_SELECTOR } from './selector.js';\n\nfunction getTabDestination(activeElement, shift) {\n    const document = activeElement.ownerDocument;\n    const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);\n    const enabledElements = Array.from(focusableElements).filter((el)=>el === activeElement || !(Number(el.getAttribute('tabindex')) < 0 || isDisabled(el)));\n    // tabindex has no effect if the active element has negative tabindex\n    if (Number(activeElement.getAttribute('tabindex')) >= 0) {\n        enabledElements.sort((a, b)=>{\n            const i = Number(a.getAttribute('tabindex'));\n            const j = Number(b.getAttribute('tabindex'));\n            if (i === j) {\n                return 0;\n            } else if (i === 0) {\n                return 1;\n            } else if (j === 0) {\n                return -1;\n            }\n            return i - j;\n        });\n    }\n    const checkedRadio = {};\n    let prunedElements = [\n        document.body\n    ];\n    const activeRadioGroup = isElementType(activeElement, 'input', {\n        type: 'radio'\n    }) ? activeElement.name : undefined;\n    enabledElements.forEach((currentElement)=>{\n        const el = currentElement;\n        // For radio groups keep only the active radio\n        // If there is no active radio, keep only the checked radio\n        // If there is no checked radio, treat like everything else\n        if (isElementType(el, 'input', {\n            type: 'radio'\n        }) && el.name) {\n            // If the active element is part of the group, add only that\n            if (el === activeElement) {\n                prunedElements.push(el);\n                return;\n            } else if (el.name === activeRadioGroup) {\n                return;\n            }\n            // If we stumble upon a checked radio, remove the others\n            if (el.checked) {\n                prunedElements = prunedElements.filter((e)=>!isElementType(e, 'input', {\n                        type: 'radio',\n                        name: el.name\n                    }));\n                prunedElements.push(el);\n                checkedRadio[el.name] = el;\n                return;\n            }\n            // If we already found the checked one, skip\n            if (typeof checkedRadio[el.name] !== 'undefined') {\n                return;\n            }\n        }\n        prunedElements.push(el);\n    });\n    for(let index = prunedElements.findIndex((el)=>el === activeElement);;){\n        index += shift ? -1 : 1;\n        // loop at overflow\n        if (index === prunedElements.length) {\n            index = 0;\n        } else if (index === -1) {\n            index = prunedElements.length - 1;\n        }\n        if (prunedElements[index] === activeElement || prunedElements[index] === document.body || isVisible(prunedElements[index])) {\n            return prunedElements[index];\n        }\n    }\n}\n\nexport { getTabDestination };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}